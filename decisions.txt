Some decisions are commented directly in source code, denoted by phrase "Ivory design note:"


* Ivory heavily relies on the type introspector, which looks up all data types defined on the database.
** The type introspector is necessary to getting type OIDs, besides some other useful metadata (such as array item separators).
** Type OIDs are necessary for identifying data types of relation result columns and processing their data correctly. The PHP pgSQL driver only allows recognizing by OID or by an unqualified name. Since there may be multiple data types of the same name in different schemas of the database, the latter is insufficient. (See also the comment for pgsql.c function php_pgsql_get_data_type: "This is stupid way to do. I'll fix it when I decied how to support user defined types. (Yasuo)".)
* The default PHP type into which Ivory will convert SQL DATE values is not \DateTime, but rather an \Ivory\Value\Date. The rationale behind this:
** It is pretty different information whether a variable holds a date or datetime. Just as it is generally better to use boolean true/false values instead of integer 1/0, a date says it is mere date, not time.
** A lot of issues is connected with datetime values - especially regarding timezones and daylight "saving" time. Working with a mere date is much simpler as no such issues are relevant for it.
** Moreover, the DATE type is discrete, while datetime is a continuous type, which may - depending on application - be a severe difference.
** Moreover, \DateTime::__construct() does not accept years of more than 4 digits; PostgreSQL may use up to 7 digits for years, though, so creating such dates for storage in the database would be complicated.
** The \Ivory\Value\Date has convenient methods to converting from/to \DateTime, thus, it shall be easy-to-use whenever one really needs to get datetime out of a date.
** After all, Ivory is so flexible that it is extremely easy to change this behaviour - just write a custom DATE type class and register it either globally or on a per-connection basis.
** The final reason, common for the decision regarding other temporal types, is that PHP made a poor choice (although performance-wise, in those days) when designing the \DateTime objects as mutable; \DateTimeImmutable, as for typing and reading such a horrible name, is quite an unsuccessful try to fix this. (That's not to undermine the whole work done for PHP date/time support - in fact, Ivory internally uses \DateTime for implementation of its own value types. It's just that the interface is not among the best.)
* Similar reasons hold for using a special Timestamp class instead of the built-in DateTime class.
* As for the own class for representing date/time intervals: the PHP built-in DateInterval is out of question as it is unable to represent mixed intervals (e.g., '-1 year -2 mons +3 days -04:05:06') - which Postgres might give on output. And, by the way, PHP's DateInterval only represents the duration, without any reasonable operations on them.
* Ivory is for PHP >= 7.1. Those who will be stuck on a PHP 7.0 (or even PHP 5) hosting will probably not change the database layer in their project, while new projects will be started right on PHP 7.1.
* Coding issue: naturally, strict types declaration does not make sense in pure interface source files. However, PhpStorm inspection "Missing strict type declaration" reports such interfaces. It is better to use the inspection at the cost of a little nonsense in interface files.

