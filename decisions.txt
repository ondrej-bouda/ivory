* Ivory heavily relies on the type introspector, which looks up all data types defined on the database.
** The type introspector is necessary to getting type OIDs, besides some other useful metadata (such as array item separators).
** Type OIDs are necessary for identifying data types of relation result columns and processing their data correctly. The PHP pgSQL driver only allows recognizing by OID or by an unqualified name. Since there may be multiple data types of the same name in different schemas of the database, the latter is insufficient.
* The default PHP type into which Ivory will convert SQL DATE values is not \DateTime, but rather an \Ivory\Value\Date. The rationale behind this:
** It is pretty different information whether a variable holds a date or datetime. Just as it is generally better to use boolean true/false values instead of integer 1/0, a date says it is mere date, not time.
** A lot of issues is connected with datetime values - especially regarding timezones and daylight "saving" time. Working with a mere date is much simpler as no such issues are relevant for it.
** Moreover, the DATE type is discrete, while datetime is a continuous type, which may - depending on application - be a severe difference.
** The \Ivory\Value\Date has convenient methods to converting from/to \DateTime, thus, it shall be easy-to-use whenever one really needs to get datetime out of a date.
** After all, Ivory is so flexible that it is extremely easy to change this behaviour - just write a custom DATE type converter and register it either globally or on a per-connection basis.
** The final reason, common for the decision regarding other temporal types, is that PHP made a poor choice (although performance-wise, in those days) when designing the \DateTime objects as mutable; \DateTimeImmutable, as for typing and reading such a horrible name, is quite an unsuccessful try to fix this. (That's not to undermine the whole work done for PHP date/time support - in fact, Ivory internally uses \DateTime for implementation of its own value types. It's just that the interface is not among the best.)
