-- noinspection SqlUnusedForFile

/**
 * Sample database created for Ivory performance tests.
 *
 * Data is generated by random functions. However, the initial seed is fixed. Thus, on the same machine, the data is
 * always identical.
 *
 * All the tables are created as UNLOGGED to speed up the database creation.
 */

CREATE SCHEMA perftest;
SET search_path = 'perftest';

--region Helpers

CREATE FUNCTION rand_int(_from INT, _to INT, _null_prob NUMERIC = NULL) RETURNS INT
AS $function$
    SELECT
        CASE WHEN random() < _null_prob
            THEN NULL
            ELSE ceil(random() * (GREATEST(_from, _to) - LEAST(_from, _to) + 1))::INT + LEAST(_from, _to) - 1
        END
$function$ LANGUAGE SQL VOLATILE;

CREATE FUNCTION rand_bool(_true_prob NUMERIC, _null_prob NUMERIC = NULL) RETURNS BOOL
AS $function$
    SELECT
        CASE WHEN random() < _null_prob
            THEN NULL
            ELSE (random() < _true_prob)
        END
$function$ LANGUAGE SQL VOLATILE;

CREATE FUNCTION rand_date(_from DATE, _to DATE, _null_prob NUMERIC = NULL) RETURNS DATE
AS $function$
    SELECT
        CASE WHEN random() < _null_prob
            THEN NULL
            ELSE LEAST(_from, _to) + rand_int(0, GREATEST(_from, _to) - LEAST(_from, _to))
        END
$function$ LANGUAGE SQL VOLATILE;

CREATE FUNCTION rand_timestamp(_from TIMESTAMP, _to TIMESTAMP, _null_prob NUMERIC = NULL) RETURNS TIMESTAMP
AS $function$
    SELECT
        CASE WHEN random() < _null_prob
            THEN NULL
            ELSE LEAST(_from, _to) + random() * (GREATEST(_from, _to) - LEAST(_from, _to))
        END
$function$ LANGUAGE SQL VOLATILE;

CREATE FUNCTION rand_timestamptz(_from TIMESTAMPTZ, _to TIMESTAMPTZ, _null_prob NUMERIC = NULL) RETURNS TIMESTAMPTZ
AS $function$
    SELECT
        CASE WHEN random() < _null_prob
            THEN NULL
            ELSE LEAST(_from, _to) + random() * (GREATEST(_from, _to) - LEAST(_from, _to))
        END
$function$ LANGUAGE SQL VOLATILE;

CREATE FUNCTION rand_str(_len_from INT, _len_to INT, _null_prob NUMERIC = NULL) RETURNS TEXT
AS $function$
    SELECT
        CASE WHEN random() < _null_prob
            THEN NULL
            ELSE
                (SELECT string_agg(chr(rand_int(ascii('a'), ascii('z'))), '' ORDER BY i)
                 FROM generate_series(1, rand_int(_len_from, _len_to)) s (i))
        END
$function$ LANGUAGE SQL VOLATILE;

CREATE FUNCTION rand_words(_len_from INT, _len_to INT) RETURNS TEXT
AS $function$
DECLARE
    result TEXT := '';
    remaining_len INT := rand_int(_len_from, _len_to);
    first BOOL := TRUE;
    word TEXT;
BEGIN
    WHILE remaining_len > 1 LOOP
        word := rand_str(1, LEAST(8, remaining_len));
        remaining_len := remaining_len - LENGTH(word);
        IF first THEN
            first := FALSE;
        ELSE
            result := result || ' ';
        END IF;
        result := result || word;
    END LOOP;
    RETURN result;
END;
$function$ LANGUAGE plpgsql VOLATILE STRICT;

CREATE FUNCTION rand_words(_len_from INT, _len_to INT, _null_prob NUMERIC) RETURNS TEXT
AS $function$
    SELECT
        CASE WHEN random() < _null_prob
            THEN NULL
            ELSE rand_words(_len_from, _len_to)
        END
$function$ LANGUAGE SQL VOLATILE;

--endregion

--region Define the schema

CREATE UNLOGGED TABLE category (
    id SERIAL PRIMARY KEY,
    name VARCHAR(80) NOT NULL,
    description TEXT,
    parent_category_id INT,
    priority INT NOT NULL DEFAULT 0
);
ALTER TABLE category ADD FOREIGN KEY (parent_category_id) REFERENCES category ON UPDATE CASCADE ON DELETE RESTRICT;
CREATE INDEX ON category (parent_category_id);
COMMENT ON TABLE category IS 'Tree of item categories.';


CREATE UNLOGGED TABLE item (
    id SERIAL PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    introduction_date DATE
);
COMMENT ON TABLE item IS 'Items offered in the shop.';

CREATE UNLOGGED TABLE item_category (
    id SERIAL PRIMARY KEY,
    item_id INT NOT NULL REFERENCES item ON UPDATE CASCADE ON DELETE CASCADE,
    category_id INT NOT NULL REFERENCES category ON UPDATE CASCADE ON DELETE RESTRICT
);
CREATE UNIQUE INDEX ON item_category (item_id, category_id);
CREATE INDEX ON item_category (category_id);
COMMENT ON TABLE item_category IS 'Relation of which item belongs in which category (might fall under multiple categories).';

CREATE UNLOGGED TABLE param (
    id SERIAL PRIMARY KEY,
    name VARCHAR(80) NOT NULL UNIQUE,
    priority INT NOT NULL DEFAULT 0
);
COMMENT ON TABLE param IS 'Parameters assignable to items.';

CREATE UNLOGGED TABLE param_value (
    id SERIAL PRIMARY KEY,
    param_id INT NOT NULL REFERENCES param ON UPDATE CASCADE ON DELETE CASCADE,
    value JSONB NOT NULL
);
CREATE INDEX ON param_value (param_id);
COMMENT ON TABLE param_value IS 'Values offered for a parameter.';

CREATE UNLOGGED TABLE item_param_value (
    id SERIAL PRIMARY KEY,
    item_id INT NOT NULL REFERENCES item ON UPDATE CASCADE ON DELETE CASCADE,
    param_id INT NOT NULL REFERENCES param ON UPDATE CASCADE ON DELETE RESTRICT,
    value JSONB NOT NULL
);
CREATE UNIQUE INDEX ON item_param_value (item_id, param_id);
CREATE INDEX ON item_param_value (param_id);
COMMENT ON TABLE item_param_value IS 'Definition of values of parameters of an item.';

CREATE UNLOGGED TABLE usr (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) NOT NULL UNIQUE,
    name VARCHAR(200) NOT NULL,
    pwd_hash VARCHAR(80) NOT NULL,
    is_active BOOL NOT NULL DEFAULT TRUE,
    last_login TIMESTAMPTZ
);
COMMENT ON TABLE usr IS 'Users of the shop.';

CREATE UNLOGGED TABLE usr_starred_item (
    id SERIAL PRIMARY KEY,
    usr_id INT NOT NULL REFERENCES usr ON UPDATE CASCADE ON DELETE CASCADE,
    item_id INT NOT NULL REFERENCES item ON UPDATE CASCADE ON DELETE CASCADE,
    star_time TIMESTAMPTZ NOT NULL DEFAULT CURRENT_TIMESTAMP
);
CREATE UNIQUE INDEX ON usr_starred_item (usr_id, item_id);
CREATE INDEX ON usr_starred_item (item_id);
COMMENT ON TABLE usr_starred_item IS 'Relation of which user has which item marked with a star.';

--endregion

--region Fill with random data.

DO LANGUAGE plpgsql $$
DECLARE
    i INT;
    j INT;
    kind INT;
    category_count INT;
    item_count INT;
    cat_placement INT[];
    rand_tz TIMESTAMPTZ;
BEGIN
    TRUNCATE category, item, item_category, param, param_value, item_param_value, usr, usr_starred_item CASCADE; -- TEMP
    PERFORM setseed(0);

    FOR i IN 1..100 LOOP
        INSERT INTO category (id, name, description, parent_category_id, priority)
            VALUES (
              i,
              'cat' || i,
              rand_words(50, 200),
              (CASE WHEN i <= 10 THEN NULL ELSE COALESCE(NULLIF(i % 10, 0), 10) END),
              rand_int(0, 10)
            );
    END LOOP;
    PERFORM setval('category_id_seq'::REGCLASS, i);

    INSERT INTO param (id, name, priority)
        VALUES
            (1, 'weight', 50),
            (2, 'dimensions', 40),
            (3, 'color', 30),
            (4, 'reliability', 20),
            (5, 'speed', 10);
    PERFORM setval('param_id_seq'::REGCLASS, (SELECT COUNT(*) FROM param));

    INSERT INTO param_value (param_id, value)
        VALUES
            (2, '{"width": 210, "height": 297}'),
            (2, '{"width": 148, "height": 210}'),
            (2, '{"width": 105, "height": 148}'),
            (3, '"red"'),
            (3, '"green"'),
            (3, '"blue"');

    category_count := (SELECT COUNT(*) FROM category);
    cat_placement := ARRAY[0, 1, 1, 1, 2, 2, 3];
    FOR i IN 1..10000 LOOP
        INSERT INTO item (id, name, description, introduction_date)
            VALUES (
                i,
                'item' || i,
                --repeat('x', rand_int(100, 1000)), -- fast way to fill lots of data
                --rand_str(100, 1000),
                rand_words(20, 100),
                rand_date('2010-01-01', '2017-03-12')
            );
        FOR j IN 1..cat_placement[rand_int(1, array_length(cat_placement, 1))] LOOP
            INSERT INTO item_category (item_id, category_id)
                VALUES (i, rand_int(1, category_count))
                ON CONFLICT (item_id, category_id) DO NOTHING;
        END LOOP;
        kind := rand_int(1, 6);
        IF kind IN (1, 3, 5) THEN
            INSERT INTO item_param_value (item_id, param_id, value) VALUES (i, 1, to_jsonb(rand_int(5, 1200)));
        END IF;
        IF kind IN (1, 2) THEN
            INSERT INTO item_param_value (item_id, param_id, value)
                SELECT i, 2, value FROM param_value WHERE param_id = 2 ORDER BY random() LIMIT 1;
        END IF;
        IF kind IN (2, 3, 4) THEN
            INSERT INTO item_param_value (item_id, param_id, value)
                SELECT i, 3, value FROM param_value WHERE param_id = 3 ORDER BY random() LIMIT 1;
        END IF;
        IF kind = 5 THEN
            INSERT INTO item_param_value (item_id, param_id, value)
                VALUES
                    (i, 4, to_jsonb(round(rand_int(50, 100) / 100.0, 1))),
                    (i, 5, to_jsonb(rand_int(160, 330)));
        END IF;
    END LOOP;
    PERFORM setval('item_id_seq'::REGCLASS, i);

    item_count := (SELECT COUNT(*) FROM item);
    FOR i IN 1..1000 LOOP
        rand_tz := rand_timestamptz('2010-01-01', '2017-03-12', .95);
        INSERT INTO usr (id, email, name, pwd_hash, is_active, last_login)
            VALUES (
                i,
                'usr' || i || '@example.com',
                'User ' || i,
                md5(i::TEXT),
                rand_bool(.9),
                rand_tz
            );
        FOR j IN 1..rand_int(0, 10) LOOP
            INSERT INTO usr_starred_item (usr_id, item_id, star_time)
                VALUES (i, rand_int(1, item_count), rand_timestamptz(rand_tz, '2017-03-12'))
                ON CONFLICT (usr_id, item_id) DO NOTHING;
        END LOOP;
    END LOOP;
    PERFORM setval('usr_id_seq'::REGCLASS, i);
END;
$$;

--endregion
