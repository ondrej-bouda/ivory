To Do:
* consider how to test the business logic if it is on the database (instead of at the application side - when an ORM is used)
** phpunit/dbunit: https://phpunit.de/manual/current/en/database.html
** pgTAP: http://pgtap.org
* design the interface for write operations
* design the interface for write operations combined with read operations (the application takes results from the database, modifies them somehow, and stores them back; that should also work for combinations of several relations; use the unique keys known for participating relations)
* consider have the project checked by:
** https://insight.sensiolabs.com
** https://codeclimate.com/github/Bee-Lab/bowerphp
* once released publicly, follow existing standards regarding the project maintenance:
** http://keepachangelog.com
** http://semver.org/spec/v2.0.0.html
* look at Laravel


Relational Approach:
* relation-centric
** data = relation => getting data = getting relation
** sources of relations:
*** static objects in database: tables, (materialized) views, set-returning functions
*** static queries = the relation structure (= the list of column names) is static
*** dynamic queries = the relation structure depends on runtime/data



Type System:
* true data types support
** the result of a query is a data row, which is nothing else than an item of the type RECORD - a data type like any other, having nested attributes of other types
** names and types of a database table columns are just a data type; PostgreSQL has this attitude, too - it generates the corresponding composite data type for each table
* Model classes reflecting database tables are just relations giving items of a given type
** auto-generate them, including nullable information, comments, etc.
** table (set-returning) functions are also relations, like tables or views; corresponding classes should also be auto-generated for them (also support function aliases)
* see the PostgreSQL object types sketch from the DVN project to get the notion of all data types
** the sketch only reflects the static types, i.e., those recognized or stored permanently by the database; dynamic runtime types shall be addressed, too
* shortcut for infering relation data types for expanding further filter conditions: execute the query with FALSE condition, grab the column data types, then use the columns name and type information for serializing input variables correctly as filter conditions; cache the result



Generator:
* generate:
** data types; mapping to native/auto-generated/recognized PHP types
** relations for tables, views, table functions
** relation constants - read from the relation data
* configuration script saying:
** what kinds of objects to generate
** what objects to generate (custom filtering possible)
** where to search (which schemas)
** how to recognize the relation constants (if ever)
* usage of the whole generator is optional
** the generated types, and type resolvers, get registered at the static Ivory
** if there is an unknown type within some results, Ivory creates a generic object on-the-fly (if it is possible)
*** for enum types, it creates an enum object, holding the enum type name and the value string
*** for range types, it creates an appropriate range type object based on the subtype
*** for composite types, it creates a generic composite type object with attributes corresponding to the database type
** the auto-generated type gets registered so that further processing of this type does not query the database repeatedly



Relation Features:
* easily support trivial CRUD operations; something like active record
* offer the RETURNING variants; e.g., updateReturning() would return a relation
* compound operations; e.g., UPSERT, INSERT IGNORE...
* writable shall be relations inferred from table or writable view relations
** or from combinations of them - use the unique keys



Supporting PostgreSQL features:
* SQL available to the user in its full strength.
* Communication with the database server encapsulated in an object-oriented interface:
** asynchronous queries
** transactions
* Writable views, not only tables.
* Leveraging constraints info - e.g., unique keys are useful for intelligent UPSERTs.
* Prepared statements.
* Two-phase commits.



Flexibility:
* Easy way to provide custom type handlers.
* Possibility to define custom exceptions thrown on specific SQL errors. Based on the SQLSTATE code or the error message, a specific exception may be thrown, thus, error processing may directly catch only the interesting exceptions using specific catch blocks, not the general StatementException.



IDE Support:
* static analysis
* ability to systematically recognize all database queries or input yielding a query, and search just within them
* ability to search for all usages of a database object (table, view, column, function, ...); e.g., search for all usages of person.name column
* symbols completion, ideally context-sensitive; especially, names of attributes of queried relations



Other Layers:
* Dibi:
** http://dibiphp.com/cs/quick-start - e.g., consider %like, %~like, %like~, and %~like~, which escape the argument as a string for LIKE or ILIKE
** http://phpfashion.com/temer-v-cili-dibi-0-9b
* Nette Database: http://doc.nette.org/cs/2.3/database
* NotORM: http://www.notorm.com
* Pomm:
** http://www.pomm-project.org/whatis
** http://www.pomm-project.org/documentation/manual-1.2
** https://github.com/chanmix51/elcaro/blob/english/documentation/article.md



Support both hackers and engineers:
* on various places, accept both \Closure and a special interface as alternative ways of specifying the behaviour
** by the way, taking interfaces will become more useful with anonymous classes in PHP 7

