Range Values
============
* Ivory is capable of processing any range type the subtype of which is known to Ivory, provided the subtype has a total
  order defined on it. Constructing the values, however, is rather complicated - the subtype and the canonical function
  must be provided for the generic Range class to know how to handle the range.
* Implement specializations of range types for the standard PostgreSQL ranges. Also, on a specific specialization,
  further methods might make sense - inspire from actual Ivory users. Suggest the user to define further specialized
  classes for their custom range types.
* Implement specializations of range values for the standard PostgreSQL ranges.



Composite Values
================
* Ivory is capable of processing any composite type. Constructing the values, however, is rather complicated - the
  composite type must be provided.
* As there are no standard composite types defined by PostgreSQL itself, the only relevant types are the user-defined
  ones (either defined explicitly, or automatically for a table).
* Implement a generator for specialized composite type and composite value classes. That could have a simple method for
  construction



Cursors
=======
* Introduce support for cursors iterating over a relation.



Auto-Transaction Handle
=======================
* ITxHandle::rollbackIfOpen() allows for pretty easy exception handling within open transactions. It still requires one
  to think of it and type some boilerplate code. In some cases (and arguably in the typical ones), just a single
  transaction is started and committed/rolled back within a one function/method.
* Implement ITransactionControl::startAutoTransaction() which would return a specialization of TxHandle, calling
  rollbackIfOpen() in __destruct(). That would even simplify the typical case:
  <code>
  function foo() {
      $tx = $conn->startAutoTransaction();
      // do stuff, exceptions expected
      $tx->commit();
  }
  </code>
* While at it, reconsider whether ICoreFactory::createTransactionHandle() is really reasonable.
* Also applicable to nested transactions - see the following feature.



Nested Transactions
===================
* A nested code block does not need to know whether it actually commits the whole transaction, or if it is just a piece
  of a wider operation. All it needs to guarantee is the atomicity - either all the statements get executed, or none.
* Similarly to output buffering, implement "transaction" nesting.
* The block tells Ivory it has finished its batch. According to whether this is an outer or inner block, the BEGIN or
  SAVEPOINT command, respectively, is really executed. Similarly, when cancelling the effect of a block, either ROLLBACK
  TRANSACTION or ROLLBACK TO SAVEPOINT is automatically chosen, allowing the outer block to recover from failure of an
  inner block, and even continue with the transaction.
* With nested transactions, one may easily cause an error simply by not treating every transaction level correctly.
  E.g., if an exception is thrown upon an error and not caught within the same transaction level, the correspondence
  between the opening and closing methods may be broken. To help fight this, the method opening a (nested) transaction
  block will return a handle. This handle must then be used for further controlling the transaction block.
  Checks shall be implemented to verify correct usage, and throw an exception on violation.
** To make it clear the returned argument does not represent the transaction itself (which it can't - only one
   transaction may be run on a single connection), represent the handle by a pure integer holding the nesting level.
   Or, on the other way round, to make the thing type-safe, return a custom object, perhaps one only Ivory is capable of
   creating.
** Upon exception being thrown due to the level mismatch, rollback up to the level where the mismatch is detected. I.e.,
   if mismatch is detected in a nested block, rollback it, throw an exception from the inner block, and allow the outer
   block catch the exception and handle it gracefully.
* Method names:
** startTransactionBlock
** commit
** rollback
* See sandpit/nested_transactions.php.
* Consider validating the correctness using generated UUIDs for savepoint names. That would require the called to
  provide the handler retrieved from startTransactionBlock() - which might be OK.
** Another option is to use savepoints named by the nesting levels.
** Another option is to use a single fixed name for savepoint names, and leverage the fact Postgres allows one to use a
   single savepoint name repeatedly.
* Try finding a way how to catch exceptions throw from erroneous queries in inner block, and handle the error within the
  outer block, with as few boilerplate code as possible. The worst would be requiring the user to catch database errors
  in the outer block by hand and forcing them to issue a block rollback and re-throw the exception.



List Serializers
================
* Implement serializers for lists of values.
* Especially, implement "li" (comma-separated list of "i") and "ls" (comma-separated list of strings).
* Useful for IN clauses (although arrays are more useful as they do not make a syntax error if empty).



Encapsulation of Database Function Calls
========================================
* Introduce methods to call database functions from PHP code directly, not by composing the function call by hand.
* Allow one to define classes representing database functions (regardless of whether permanent or temporary), and
  instantiating them to call them.
* Distinguish void, scalar, and set-returning functions. That would either lead to a relation recipe or command recipe,
  which would also be used in more complex queries. Scalar function results might be used as parameters in complex
  queries, or as just a value to fetch.



Extend the Database Introspector
================================
* Implement a full-featured introspector of database objects.
* Consider implementing that as a separate package, pluggable to Ivory.
* Encapsulate the introspector as a standalone class, used by the type dictionary compiler.
* Take the full strength from the DVN project.
* Offer methods for testing the database being connected to - tables, data types, functions...
** Especially useful for custom type/function objects to check that the database actually has the type or function
   defined.



Synchronized Type Dictionary
============================
* Currently, the type dictionary is cached for the whole script lifetime, or even among individual requests. As such,
  any changes to type registers or in the connected-to database are not reflected by the Type Dictionary.
* The only way to handle such changes after the Type Dictionary is set up is to manually call the
  ITypeControl::flushTypeDictionary() method.
* Implement updating the type dictionary according to the changes in type registers.
* Update the docs for TypeRegister then - currently, it says: "later registration changes of types, types loaders or
  type supplements are not reflected".



Implement Data Source
=====================
* Introduce DataSource - an SqlRecipe paired with a database connection, ready to be executed.
* Both having explicit methods like execute() or query(), and directly iterable, executing the query in the background.
* Occurrences:
** IStatementExecution::dataSource() + implementations
** IRelationRecipe::toDataSource(IConnection)
** DataSource::fromRecipe(IRelationRecipe, IConnection)
* Consider specifying a smaller part of IConnection to be held by the data source, just the necessary methods for a
  recipe to be executable.



Global Ivory Methods
====================
* Implement Ivory::query() constructing a QueryRelation, or Ivory::expr() constructing an expression, applied on the
  default connection.



BLOBS
=====
* Implement support for large binary objects.



Prepared Statements
===================
* Ivory has a powerful way to compose queries with placeholders. It does not implement the true prepared statements,
  which could be cached by the PostgreSQL itself and thus lead to a performance gain.
* Extend IStatementExecution with methods for preparing a statement and executing it.
* Allow combining prepared statements with Ivory built-in methods for composing SQL statements.



Catch All PostgreSQL Notices
============================
* Ivory catches all exceptions raised by PostgreSQL. As for notices, though, only the last notice is currently available
  due to the limitations of the pgsql extension.
* Try to find a way to catch all notices raised for each statement, not just the last one.
* E.g., consider file tracing, preferably to a memory-mapped file, and process the file asynchronously, apart from the
  application itself. Then, write some custom information to the log file, like the stack trace.




